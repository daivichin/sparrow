/**
 *    Copyright 2023 sdeven.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.java.sdeven.sparrow.commons.timewheel.timewheel.holder;

import com.google.common.collect.Maps;
import com.java.sdeven.sparrow.commons.timewheel.timewheel.HashedWheelTimer;
import com.java.sdeven.sparrow.commons.timewheel.timewheel.TimerFuture;
import com.java.sdeven.sparrow.commons.timewheel.timewheel.TimerTask;

import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Timed scheduling task instance service
 * @author sdeven
 * @since 1.0.0
 */
public class InstanceTimeWheelService {

    private static final Map<Long, TimerFuture> CARGO = Maps.newConcurrentMap();

    /** Precise scheduling of the time wheel, one frame every 1MS */
    private static final HashedWheelTimer TIMER = new HashedWheelTimer(1, 4096, Runtime.getRuntime().availableProcessors() * 4);
    /** Non-exact scheduling time wheel for high latency tasks, one frame every 10S */
    private static final HashedWheelTimer SLOW_TIMER = new HashedWheelTimer(10000, 12, 0);

    /** The time interval to support cancellation, below which CARGO will not be released */
    private static final long MIN_INTERVAL_MS = 1000;
    /** Long Delay Threshold */
    private static final long LONG_DELAY_THRESHOLD_MS = 60000;

    /**
     * Scheduling
     * @param uniqueId Unique ID, must be the ID generated by the snowflake algorithm
     * @param delayTime Delayed milliseconds
     * @param timerTask Targeted Approach to Implementation
     */
    public static void schedule(Long uniqueId, Long delayTime, TimerTask timerTask) {
        if (delayTime <= LONG_DELAY_THRESHOLD_MS) {
            realSchedule(uniqueId, delayTime, timerTask);
            return;
        }

        long expectTriggerTime = System.currentTimeMillis() + delayTime;
        TimerFuture longDelayTask = SLOW_TIMER.schedule(() -> {
            CARGO.remove(uniqueId);
            realSchedule(uniqueId, expectTriggerTime - System.currentTimeMillis(), timerTask);
        }, delayTime - LONG_DELAY_THRESHOLD_MS, TimeUnit.MILLISECONDS);
        CARGO.put(uniqueId, longDelayTask);
    }

    /**
     * Get TimerFuture
     * @param #uniqueId
     * @return {@link TimerFuture}
     */
    public static TimerFuture fetchTimerFuture(Long uniqueId) {
        return CARGO.get(uniqueId);
    }


    private static void realSchedule(Long uniqueId, Long delayMS, TimerTask timerTask) {
        TimerFuture timerFuture = TIMER.schedule(() -> {
            CARGO.remove(uniqueId);
            timerTask.run();
        }, delayMS, TimeUnit.MILLISECONDS);
        if (delayMS > MIN_INTERVAL_MS) {
            CARGO.put(uniqueId, timerFuture);
        }
    }

}
